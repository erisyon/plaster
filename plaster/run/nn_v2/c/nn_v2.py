import numpy as np
from plumbum import local, FG
import ctypes as c
from contextlib import contextmanager
from plaster.tools.c_common import c_common_tools
from plaster.tools.c_common.c_common_tools import Tab
from plaster.run.sim_v2.sim_v2_params import (
    RadType,
    DyeType,
    DyePepType,
    DytWeightType,
    DytIndexType,
)
from plaster.run.nn_v2.c.build import build
from contextlib import redirect_stdout, redirect_stderr


class NNV2Context(c_common_tools.FixupStructure):
    _fixup_fields = [
        # # Input Tables
        ("train_fdyemat", Tab, RadType),
        ("train_dyepeps", Tab, DyePepType),  # 3 columns: (dyt_i, pep_i, count)
        ("radmat", Tab, RadType),
        # Parameters
        ("beta", "Float64"),
        ("sigma", "Float64"),
        ("zero_mu", "Float64"),
        ("zero_sigma", "Float64"),
        ("row_k_std", "Float64"),
        # Options
        ("n_neighbors", "Size"),
        ("run_row_k_fit", "Bool"),
        ("run_against_all_dyetracks", "Bool"),
        # # Derived properties
        ("n_cols", "Size"),
        # ("train_dyt_i_to_dyepep_offset", "Tab"),
        # # Outputs
        ("output", Tab, np.float64),  # 3 columns: (pred_dyt_iz, score, zscore)
        # # Internal fields
        ("_stop_requested", "Bool"),
        # ("_work_order_lock", "pthread_mutex_t"),
        # ("_flann_index_lock", "pthread_mutex_t"),
        # ("_pyfunction_lock", "pthread_mutex_t"),
        ("_flann_params", "struct FLANNParameters *"),
        ("_flann_index_id", "void *"),
        ("_dyt_weights", Tab, DytWeightType),
        ("_dyt_i_to_dyepep_offset", Tab, DytIndexType),
    ]

    @property
    def pred_dyt_iz(self):
        return self._output[:, 0].astype(int)


_lib = None

recompile = True


def load_lib():
    global _lib
    if _lib is not None:
        return _lib

    NNV2Context.struct_fixup()

    with local.cwd("/erisyon/plaster/plaster/run/nn_v2/c"):
        if recompile:
            with open("./_nn_v2.h", "w") as fp:
                with redirect_stdout(fp):
                    print(f"// This file was code-generated by nn_v2.c.nn_v2.load_lib")
                    print()
                    print("#ifndef NN_V2_H")
                    print("#define NN_V2_H")
                    print()
                    print('#include "pthread.h"')
                    print('#include "stdint.h"')
                    print('#include "c_common.h"')
                    print()
                    NNV2Context.struct_emit_header(fp)
                    print("#endif")

            build(
                dst_folder="/erisyon/plaster/plaster/run/nn_v2/c",
                c_common_folder="/erisyon/plaster/plaster/tools/c_common",
                flann_include_folder="/flann/src/cpp/flann",
                flann_lib_folder="/flann/lib",
            )
        lib = c.CDLL("./_nn_v2.so")

    lib.sanity_check()

    lib.context_init.argtypes = [
        c.POINTER(NNV2Context),
    ]
    lib.context_init.restype = c.c_char_p

    lib.context_free.argtypes = [
        c.POINTER(NNV2Context),
    ]

    lib.classify_radrows.argtypes = [
        c.POINTER(NNV2Context),  # NNV2Context *ctx
        c_common_tools.typedef_to_ctype("Index"),  # Index radrow_start_i,
        c_common_tools.typedef_to_ctype("Size"),  # Size n_radrows,
    ]
    lib.classify_radrows.restype = c.c_char_p

    _lib = lib
    return lib


class NNV2Exception(Exception):
    def __init__(self, s):
        super().__init__(s.decode("ascii"))


@contextmanager
def context(
    train_dyemat,
    train_dyepeps,
    radmat,
    beta,
    sigma,
    zero_beta,
    zero_sigma,
    row_k_std,
    n_neighbors=8,
    run_row_k_fit=False,
    run_against_all_dyetracks=False,
):
    """
    with nn_v2.context(...) as ctx:
        zap.work_orders(do_classify_radrows, ...)
    """
    lib = load_lib()

    output_dtype = NNV2Context.tab_type("output")
    output = np.zeros((radmat.shape[0], 3), dtype=output_dtype)

    # This is a possible place to optimize to avoid this conversion to float
    # But as it is now it is needed because the FLANN needs to lookup by float
    # so it is easier to convert is all here to RadType.
    train_fdyemat = train_dyemat.astype(RadType)

    nn_v2_context = NNV2Context(
        train_fdyemat=Tab.from_mat(
            train_fdyemat, NNV2Context.tab_type("train_fdyemat")
        ),
        train_dyepeps=Tab.from_mat(
            train_dyepeps, NNV2Context.tab_type("train_dyepeps")
        ),
        radmat=Tab.from_mat(radmat, NNV2Context.tab_type("radmat")),
        beta=beta,
        sigma=sigma,
        zero_beta=zero_beta,
        zero_sigma=zero_sigma,
        row_k_std=row_k_std,
        n_neighbors=n_neighbors,
        run_row_k_fit=run_row_k_fit,
        run_against_all_dyetracks=run_against_all_dyetracks,
        n_cols=train_fdyemat.shape[1],
        output=Tab.from_mat(output, output_dtype),
        _output=output,
    )

    error = lib.context_init(nn_v2_context)
    if error is not None:
        raise NNV2Exception(error)

    try:
        yield nn_v2_context
    finally:
        lib.context_free(nn_v2_context)


def do_classify_radrows(nn_v2_context, radrow_start_i, n_radrows):
    lib = load_lib()
    error = lib.classify_radrows(nn_v2_context, radrow_start_i, n_radrows)
    if error is not None:
        raise NNV2Exception(error)
