import numpy as np
from plumbum import local, FG
import ctypes as c
from contextlib import contextmanager
from plaster.tools.schema import check
from plaster.run.error_model import GainModel
from plaster.tools.c_common import c_common_tools
from plaster.tools.c_common.c_common_tools import Tab
from plaster.run.sim_v2.sim_v2_params import (
    RadType,
    DyePepType,
    DytWeightType,
    DytIndexType,
)
from plaster.run.nn_v2.c.build import build
from contextlib import redirect_stdout, redirect_stderr
from plaster.tools.log.log import debug


class NNV2Context(c_common_tools.FixupStructure):
    # fmt: off
    _fixup_fields = [
        # Input Tables
        ("train_fdyemat", Tab, RadType),
        ("train_dyepeps", Tab, DyePepType),  # 3 columns: (dyt_i, pep_i, count)
        ("radmat", Tab, RadType),

        # Parameters
        ("beta", "Float64"),
        ("sigma", "Float64"),
        ("zero_beta", "Float64"),
        ("zero_sigma", "Float64"),
        ("row_k_beta", "Float64"),
        ("row_k_sigma", "Float64"),

        # Options
        ("n_neighbors", "Size"),
        ("run_row_k_fit", "Bool"),
        ("run_against_all_dyetracks", "Bool"),
        ("use_row_k_p_val", "Bool"),

        # Derived properties
        ("n_cols", "Size"),

        # Outputs

        # Main output: 5 columns: (pred_dyt_i, pred_pep_i, dyt_score, score, pred_k)
        # This will always be returned even when run_against_all_dyetracks is True
        ("output", Tab, np.float64),

        # against_all_dyetracks_output is only used when run_against_all_dyetracks is True
        # in which case it is table of n_radrows with n_dyt*2 columns
        # where the columns are in pairs (p_val, pred_k)
        ("against_all_dyetracks_output", Tab, np.float64),

        # Internal fields
        ("_stop_requested", "Bool"),
        ("_flann_params", "struct FLANNParameters *"),
        ("_flann_index_id", "void *"),
        ("_dyt_weights", Tab, DytWeightType),
        ("_dyt_i_to_dyepep_offset", Tab, DytIndexType),

        # TODO:
        # ("_work_order_lock", "pthread_mutex_t"),
        # ("_flann_index_lock", "pthread_mutex_t"),
        # ("_pyfunction_lock", "pthread_mutex_t"),
    ]
    # fmt: on

    def bad_pred_mask(self):
        return self.pred_dyt_iz == 0

    @property
    def pred_dyt_iz(self):
        return self._output[:, 0].astype(int)

    @property
    def pred_pep_iz(self):
        return self._output[:, 1].astype(int)

    @property
    def pred_dyt_scores(self):
        return self._output[:, 2]

    @property
    def pred_scores(self):
        return self._output[:, 3]

    @property
    def pred_ks(self):
        pks = self._output[:, 4]
        pks[self.bad_pred_mask()] = np.nan
        return pks

    @property
    def sum_log_z_score(self):
        slzs = self._output[:, 5]
        slzs[self.bad_pred_mask()] = np.nan
        return slzs

    @property
    def against_all_dyetrack_pvals(self):
        n_cols = self._against_all_dyetracks_output.shape[1]
        return self._against_all_dyetracks_output[:, 0 : n_cols // 3]

    @property
    def against_all_dyetrack_pred_ks(self):
        n_cols = self._against_all_dyetracks_output.shape[1]
        return self._against_all_dyetracks_output[:, n_cols // 3 :]

    @property
    def against_all_dyetrack_sum_log_z_scores(self):
        n_cols = self._against_all_dyetracks_output.shape[1]
        return self._against_all_dyetracks_output[:, 2 * n_cols // 3 :]


_lib = None

recompile = True


def load_lib():
    global _lib
    if _lib is not None:
        return _lib

    NNV2Context.struct_fixup()

    with local.cwd("/erisyon/plaster/plaster/run/nn_v2/c"):
        if recompile:
            with open("./_nn_v2.h", "w") as fp:
                with redirect_stdout(fp):
                    print(f"// This file was code-generated by nn_v2.c.nn_v2.load_lib")
                    print()
                    print("#ifndef NN_V2_H")
                    print("#define NN_V2_H")
                    print()
                    print('#include "pthread.h"')
                    print('#include "stdint.h"')
                    print('#include "c_common.h"')
                    print()
                    NNV2Context.struct_emit_header(fp)
                    print("#endif")

            build(
                dst_folder="/erisyon/plaster/plaster/run/nn_v2/c",
                c_common_folder="/erisyon/plaster/plaster/tools/c_common",
                flann_include_folder="/flann/src/cpp/flann",
                flann_lib_folder="/flann/lib",
            )
        lib = c.CDLL("./_nn_v2.so")

    lib.sanity_check()

    lib.context_init.argtypes = [
        c.POINTER(NNV2Context),
    ]
    lib.context_init.restype = c.c_char_p

    lib.context_free.argtypes = [
        c.POINTER(NNV2Context),
    ]

    lib.classify_radrows.argtypes = [
        c.POINTER(NNV2Context),  # NNV2Context *ctx
        c_common_tools.typedef_to_ctype("Index"),  # Index radrow_start_i,
        c_common_tools.typedef_to_ctype("Size"),  # Size n_radrows,
    ]
    lib.classify_radrows.restype = c.c_char_p

    _lib = lib
    return lib


class NNV2Exception(Exception):
    def __init__(self, s):
        super().__init__(s.decode("ascii"))


@contextmanager
def context(
    train_dyemat,
    train_dyepeps,
    radmat,
    gain_model,
    n_neighbors=8,
    run_row_k_fit=False,
    run_against_all_dyetracks=False,
    use_row_k_p_val=True,
):
    """
    with nn_v2.context(...) as ctx:
        zap.work_orders(do_classify_radrows, ...)
    """
    lib = load_lib()

    check.t(gain_model, GainModel)
    assert gain_model.n_channels == 1  # Temporary

    output_dtype = NNV2Context.tab_type("output")
    output = np.zeros((radmat.shape[0], 6), dtype=output_dtype)

    # This is a possible place to optimize to avoid this conversion to float
    # But as it is now it is needed because the FLANN needs to lookup by float
    # so it is easier to convert is all here to RadType.
    train_fdyemat = train_dyemat.astype(RadType)
    n_dyts = train_fdyemat.shape[0]
    n_radrows = radmat.shape[0]

    against_all_dyetracks_output_dtype = None
    against_all_dyetracks_output = None
    if run_against_all_dyetracks:
        against_all_dyetracks_output_dtype = NNV2Context.tab_type(
            "against_all_dyetracks_output"
        )
        against_all_dyetracks_output = np.zeros(
            (n_radrows, 3 * n_dyts), dtype=against_all_dyetracks_output_dtype
        )

    nn_v2_context = NNV2Context(
        train_fdyemat=Tab.from_mat(
            train_fdyemat, NNV2Context.tab_type("train_fdyemat")
        ),
        train_dyepeps=Tab.from_mat(
            train_dyepeps, NNV2Context.tab_type("train_dyepeps")
        ),
        radmat=Tab.from_mat(radmat, NNV2Context.tab_type("radmat")),
        # Temporary hard-coding of channel 0
        beta=gain_model.channels[0].beta,
        sigma=gain_model.channels[0].sigma,
        zero_beta=gain_model.channels[0].zero_beta,
        zero_sigma=gain_model.channels[0].zero_sigma,
        row_k_beta=gain_model.row_k_beta,
        row_k_sigma=gain_model.row_k_sigma,
        n_neighbors=n_neighbors,
        run_row_k_fit=run_row_k_fit,
        run_against_all_dyetracks=run_against_all_dyetracks,
        use_row_k_p_val=use_row_k_p_val,
        n_cols=train_fdyemat.shape[1],
        output=Tab.from_mat(output, output_dtype),
        _output=output,
        against_all_dyetracks_output=Tab.from_mat(
            against_all_dyetracks_output, against_all_dyetracks_output_dtype
        ),
        _against_all_dyetracks_output=against_all_dyetracks_output,
    )

    error = lib.context_init(nn_v2_context)
    if error is not None:
        raise NNV2Exception(error)

    try:
        yield nn_v2_context
    finally:
        lib.context_free(nn_v2_context)


def do_classify_radrows(nn_v2_context, radrow_start_i, n_radrows):
    lib = load_lib()
    error = lib.classify_radrows(nn_v2_context, radrow_start_i, n_radrows)
    if error is not None:
        raise NNV2Exception(error)
