"""
Our instrument images involve stage movement during each field.
So cycle 0 and cycle 1 of the same "field (region of the slow cell)
are usually mis-aligned by a few microns which translates into tens
of pixels of misalignment.

A single-pixel alignment is relatively easy but a full image sub-pixel
alignment is trickier due to memory constraints.

The single pixel alignment is done by a 2D convolution of cycles 1+
relative to cycle 0 an d then picking the maximum coordinate of the
convolution as the shift.  (The scipy convolve function actually runs
a DFT and is very fast -- note that convolve(a,b) is the same as
ifft(fft(a) * fft(B))

But sub-pixel by that method would seem to imply that I would need to scale
the images byt eh sub-pixel factor of, let's say 100 fold.  Thus an image
of 1024x1024 become (102400 x 102400) = ten thousand fold larger.

So this code takes the following approach to avoid that memory explosion.

1. Do a single pixel alignment as described.
2. Slice the image horizontally into smallish strips (full width but only
   a few pixels tall)
3. Sum the strip vertically making this in to a 1D cross-section.
4. Upscale the 1D cross-seciton by cubic spline interpolation by the scale factor (100)
5. "Narrow convolve" the 1D signal of cycle 1+ with the equivalent slice
   of cycle 0.  But we know that the shift is within 1 pixel (100 units in the
   upscaled version) thus we don't need a full convolution across the
   entire "large" function -- only within 100 units on either side of zero
   so this can be implemented with a for-loop summing over product of
   sum(cy[0], shifted(cy[i]))

NOTE: This module should be deprecated and replaced with a gradient
descent based FFT method once I have a chance to coordinate with JHD.

"""


import numpy as np
from plumbum import local
import ctypes as c
from io import StringIO
from contextlib import contextmanager, redirect_stderr, redirect_stdout
from plaster.tools.schema import check
from plaster.tools.zap import zap
from plaster.run.sigproc_v2.c_sub_pixel_align.build import build
from plaster.tools.c_common.c_common_tools import CException
from plaster.tools.image import imops, coord
from plaster.tools.utils import utils
from plaster.tools.c_common import c_common_tools
from plaster.tools.c_common.c_common_tools import F64Arr
from plaster.tools.log.log import debug


class SubPixelAlignContext(c_common_tools.FixupStructure):
    # fmt: off
    _fixup_fields = [
        ("cy_ims", F64Arr),  # Already 1-pixel aligned

        # Parameters
        ("n_cycles", "Size"),
        ("mea_h", "Size"),
        ("mea_w", "Size"),
        ("slice_h", "Size"),
        ("scale", "Size"),

        # Outputs
        ("out_offsets", F64Arr),

        # Internal fields
        ("_n_slices", "Size"),
        ("_large_cy0_slices", F64Arr),
    ]
    # fmt: on


_lib = None


c_sub_pixel_align_path = local.path("/erisyon/plaster/plaster/run/sigproc_v2/c_sub_pixel_align")

def init():
    """
    Must be called before anything else in this module
    """
    debug("BUILD C SUB PIXEL ALIGN")

    SubPixelAlignContext.struct_fixup()

    with local.cwd(c_sub_pixel_align_path):
        fp = StringIO()
        with redirect_stdout(fp):
            print(
                f"// This file was code-generated by sigproc_v2.c_sub_pixel_align.c_sub_pixel_align.load_lib"
            )
            print()
            print("#ifndef SUB_PIXEL_ALIGN_H")
            print("#define SUB_PIXEL_ALIGN_H")
            print()
            print('#include "stdint.h"')
            print('#include "c_common.h"')
            print()
            SubPixelAlignContext.struct_emit_header(fp)
            print("#endif")

        header_file_path = "./_sub_pixel_align.h"
        existing_h = utils.load(header_file_path, return_on_non_existing="")

        if existing_h != fp.getvalue():
            utils.save(header_file_path, fp.getvalue())

        build(
            dst_folder=c_sub_pixel_align_path,
            c_common_folder="/erisyon/plaster/plaster/tools/c_common",
        )
        lib = c.CDLL("./_sub_pixel_align.so")



def load_lib():
    global _lib
    if _lib is not None:
        return _lib

    SubPixelAlignContext.struct_fixup()

    lib = c.CDLL(c_sub_pixel_align_path / "_sub_pixel_align.so")

    lib.context_init.argtypes = [
        c.POINTER(SubPixelAlignContext),
    ]
    lib.context_init.restype = c.c_char_p

    lib.context_free.argtypes = [
        c.POINTER(SubPixelAlignContext),
    ]

    lib.sub_pixel_align_one_cycle.argtypes = [
        c.POINTER(SubPixelAlignContext),  # SubPixelAlignContext context
        c_common_tools.typedef_to_ctype("Index"),  # Index radrow_start_i,
    ]
    lib.sub_pixel_align_one_cycle.restype = c.c_char_p

    _lib = lib
    return lib


@contextmanager
def context(pixel_aligned_cy_ims, slice_h):
    """
    with sub_pixel_align.context(...) as ctx:
        zap.work_orders(do_sub_pixel_align, ...)
    """
    lib = load_lib()

    check.array_t(pixel_aligned_cy_ims, ndim=3, dtype=np.float64)
    n_cycles, mea_h, mea_w = pixel_aligned_cy_ims.shape

    out_offsets = np.zeros((n_cycles,), dtype=np.float64)

    ctx = SubPixelAlignContext(
        cy_ims=F64Arr.from_ndarray(pixel_aligned_cy_ims),
        n_cycles=n_cycles,
        mea_h=mea_h,
        mea_w=mea_w,
        slice_h=slice_h,
        scale=100,
        out_offsets=F64Arr.from_ndarray(out_offsets),
        _out_offsets=out_offsets,
    )

    error = lib.context_init(ctx)
    if error is not None:
        raise CException(error)

    try:
        yield ctx
    finally:
        lib.context_free(ctx)


def _do_sub_pixel_align_cycle(cy_i, ctx):
    lib = load_lib()
    error = lib.sub_pixel_align_one_cycle(ctx, cy_i)
    if error is not None:
        raise CException(error)


def sub_pixel_align_cy_ims(cy_ims, slice_h):
    """
    The C implementation of the sub=-pixel aligner **ONLY** operates
    on the x (horizontal) dimension.  To get the vertical you need to
    transpose the image-stack and run it through the same algorithm
    which is slightly less efficient but massively simplifies the
    C implementation as it eliminates all cross indexing terms
    ("Am I walking through this vertically or horizontally now?")

    Returns:
        offsets: ndarray(n_cycles, 2); where 2 is (y, x)
    """

    check.array_t(cy_ims, ndim=3, dtype=np.float64)

    n_cycles = cy_ims.shape[0]

    def _run(cy_ims):
        """
        cy_ims are single-pixel aligned.
        This wraps the C function that runs ony on the horizontal
        """

        # For reference, align returns the position. That is, you
        # must shift a cycle in the OPPOSITE direction to make it line up.
        # Example: Cy0 there's a peak at 10 and at cy1 the peak is now
        # at 15. Therefore cy1 must be shifted left 5 (ie -5) to align with cy0

        if n_cycles <= 1:
            return np.zeros((1,))

        with context(cy_ims, slice_h) as ctx:
            zap.arrays(
                _do_sub_pixel_align_cycle,
                dict(cy_i=list(range(1, n_cycles))),
                _process_mode=False,
                _trap_exceptions=False,
                ctx=ctx,
            )

        return ctx._out_offsets

    pixel_offsets, pixel_aligned_cy_ims = imops.align(cy_ims, return_shifted_ims=True)

    aln_x = _run(pixel_aligned_cy_ims)

    # Transpose and repeat
    t_pixel_aligned_cy_ims = np.ascontiguousarray(
        np.transpose(pixel_aligned_cy_ims, (0, 2, 1)), dtype=np.float64
    )
    aln_y = _run(t_pixel_aligned_cy_ims)

    return np.vstack((aln_y, aln_x)).T + pixel_offsets


def sub_pixel_align_chcy_ims(chcy_ims, **kwargs):
    """
    At some point we may need to align the channels independently.
    For now, combine channels and pass to sub_pixel_align_cy_ims
    """
    check.array_t(chcy_ims, ndim=4, dtype=np.float64)
    cy_ims = np.sum(chcy_ims, axis=0)
    return sub_pixel_align_cy_ims(cy_ims, **kwargs)
