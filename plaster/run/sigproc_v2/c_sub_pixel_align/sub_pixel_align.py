import numpy as np
from plumbum import local
import ctypes as c
from io import StringIO
from contextlib import contextmanager, redirect_stderr, redirect_stdout
from plaster.tools.schema import check
from plaster.tools.zap import zap
from plaster.run.sigproc_v2.c_sub_pixel_align.build import build
from plaster.tools.c_common.c_common_tools import CException
from plaster.tools.image import imops, coord
from plaster.tools.utils import utils
from plaster.tools.c_common import c_common_tools
from plaster.tools.c_common.c_common_tools import F64Arr
from plaster.tools.log.log import debug


class SubPixelAlignContext(c_common_tools.FixupStructure):
    # fmt: off
    _fixup_fields = [
        ("cy_ims", F64Arr),  # Already 1-pixel aligned

        # Parameters
        ("n_cycles", "Size"),
        ("mea_h", "Size"),
        ("mea_w", "Size"),
        ("slice_h", "Size"),
        ("scale", "Size"),

        # Outputs
        ("out_offsets", F64Arr),

        # Internal fields
        ("_n_slices", "Size"),
        ("_large_cy0_slices", F64Arr),
    ]
    # fmt: on


_lib = None


def load_lib():
    global _lib
    if _lib is not None:
        return _lib

    SubPixelAlignContext.struct_fixup()

    with local.cwd("/erisyon/plaster/plaster/run/sigproc_v2/c_sub_pixel_align"):
        fp = StringIO()
        with redirect_stdout(fp):
            print(
                f"// This file was code-generated by sigproc_v2.c_sub_pixel_align.c_sub_pixel_align.load_lib"
            )
            print()
            print("#ifndef SUB_PIXEL_ALIGN_H")
            print("#define SUB_PIXEL_ALIGN_H")
            print()
            print('#include "stdint.h"')
            print('#include "c_common.h"')
            print()
            SubPixelAlignContext.struct_emit_header(fp)
            print("#endif")

        header_file_path = "./_sub_pixel_align.h"
        existing_h = utils.load(header_file_path, return_on_non_existing="")

        if existing_h != fp.getvalue():
            utils.save(header_file_path, fp.getvalue())

        build(
            dst_folder="/erisyon/plaster/plaster/run/sigproc_v2/c_sub_pixel_align",
            c_common_folder="/erisyon/plaster/plaster/tools/c_common",
        )
        lib = c.CDLL("./_sub_pixel_align.so")

    lib.context_init.argtypes = [
        c.POINTER(SubPixelAlignContext),
    ]
    lib.context_init.restype = c.c_char_p

    lib.context_free.argtypes = [
        c.POINTER(SubPixelAlignContext),
    ]

    lib.sub_pixel_align_one_cycle.argtypes = [
        c.POINTER(SubPixelAlignContext),  # SubPixelAlignContext context
        c_common_tools.typedef_to_ctype("Index"),  # Index radrow_start_i,
    ]
    lib.sub_pixel_align_one_cycle.restype = c.c_char_p

    _lib = lib
    return lib


@contextmanager
def context(pixel_aligned_cy_ims, slice_h):
    """
    with sub_pixel_align.context(...) as ctx:
        zap.work_orders(do_sub_pixel_align, ...)
    """
    lib = load_lib()

    check.array_t(pixel_aligned_cy_ims, ndim=3, dtype=np.float64)
    n_cycles, mea_h, mea_w = pixel_aligned_cy_ims.shape

    out_offsets = np.zeros((n_cycles,), dtype=np.float64)

    ctx = SubPixelAlignContext(
        cy_ims=F64Arr.from_ndarray(pixel_aligned_cy_ims),
        n_cycles=n_cycles,
        mea_h=mea_h,
        mea_w=mea_w,
        slice_h=slice_h,
        scale=100,
        out_offsets=F64Arr.from_ndarray(out_offsets),
        _out_offsets=out_offsets,
    )

    error = lib.context_init(ctx)
    if error is not None:
        raise CException(error)

    try:
        yield ctx
    finally:
        lib.context_free(ctx)


def _do_sub_pixel_align_cycle(cy_i, ctx):
    lib = load_lib()
    error = lib.sub_pixel_align_one_cycle(ctx, cy_i)
    if error is not None:
        raise CException(error)


def sub_pixel_align_cy_ims(cy_ims):
    check.array_t(cy_ims, ndim=3, dtype=np.float64)

    slice_h = 30  # TODO: Change to correct value!!

    n_cycles = cy_ims.shape[0]

    def _run(_cy_ims):
        # For reference, align returns the position. That is, you
        # must shift a cycle in the OPPOSITE direction to make it line up.
        # Example: Cy0 there's a peak at 10 and at cy1 the peak is now
        # at 15. Therefore cy1 must be shifted left 5 (ie -5) to align with cy0

        pixel_offsets, pixel_aligned_cy_ims = imops.align(
            _cy_ims, return_shifted_ims=True
        )

        with context(pixel_aligned_cy_ims, slice_h) as ctx:
            zap.arrays(
                _do_sub_pixel_align_cycle,
                dict(cy_i=list(range(1, n_cycles))),
                _debug_mode=True,  # TODO REMOVE ME!
                _process_mode=False,
                _trap_exceptions=False,
                ctx=ctx,
            )

        # Remember the _do_sub_pixel_align_cycle only aligns the x axis.
        # So the pixel_offsets[:, 1] is the corresponding pixel-shift value.
        return pixel_offsets[:, 1] + ctx._out_offsets

    aln_x = _run(cy_ims)

    # Transpose and repeat
    transposed_cy_ims = np.transpose(cy_ims, (0, 2, 1))
    aln_y = _run(transposed_cy_ims)

    return np.vstack((aln_y, aln_x)).T


def sub_pixel_align_chcy_ims(chcy_ims):
    """
    At some point we may need to align the channels independently.
    For now, combine channels and pass to sub_pixel_align_cy_ims
    """

    check.array_t(chcy_ims, ndim=4, dtype=np.float64)

    cy_ims = np.sum(chcy_ims, axis=0)
    return sub_pixel_align_cy_ims(cy_ims)
