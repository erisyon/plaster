from munch import Munch
from plaster.gen.base_generator import BaseGenerator
from plaster.gen import task_templates
from plaster.tools.schema.schema import Schema as s
from plaster.tools.utils import utils
from plaster.gen.report_builder import ReportBuilder
from plaster.tools.log.log import debug, current_file_and_line_str
from plumbum import local


class SigprocV2Generator(BaseGenerator):
    """
    Examine sigproc_v2 and study their results.
    Note that this requires a calibration file produced by running the run
    generated by the sigproc_v2_calibration generator.
    """

    schema = s(
        s.is_kws_r(
            **BaseGenerator.sigproc_v2_schema.schema(),
            **BaseGenerator.lnfit_schema.schema(),
            **BaseGenerator.error_model_schema.schema(),
            classify_dyetracks=s.is_bool(help="If true then compare to dyetracks"),
            dyetrack_n_cycles=s.is_int(
                noneable=True, help="Number of cycles of simulated dyetracks"
            ),
            dyetrack_n_counts=s.is_int(noneable=True, help="Number of dyes max."),
            is_timelapse=s.is_bool(help="Is a timelapse experiment"),
        )
    )

    defaults = Munch(classify_dyetracks=False, is_timelapse=False,)

    def generate(self):
        runs = []

        lnfit_tasks = self.lnfits(sigproc_version="v2")

        assert isinstance(self.sigproc_source, str)

        ims_import_task = task_templates.ims_import(self.sigproc_source, is_movie=False)

        calib_src_path = local.path(self.calibration_file)
        calib_dst_path = local.path(self.local_sources_tmp_folder) / calib_src_path.name
        calib_src_path.copy(calib_dst_path)
        sigproc_v2_task = task_templates.sigproc_v2_analyze(
            self.gen_sources_folder / calib_src_path.name
        )

        nn_n2_task = {}
        if self.classify_dyetracks:
            # TODO: This is a bit of a hacked up mess, this mode is
            # used for calibration purposes and might not be a long-term
            # feature and so is using hard-coded n_channels for example
            self.label_set = [""]
            self.scheme = []
            n_schemes = 0
            for protease, label_set, err_set in self.run_parameter_permutator():
                nn_n2_task = task_templates.nn_v2(
                    "../sigproc_v2",
                    err_set,
                    prep_folder=None,
                    sim_v2_folder=None,
                    run_against_all_dyetracks=True,
                    run_row_k_fit=True,
                    include_sigproc=True,
                    dyetrack_n_cycles=self.dyetrack_n_cycles,
                    dyetrack_n_counts=self.dyetrack_n_counts,
                )

                n_schemes += 1

            assert n_schemes == 1

        run = Munch(
            run_name=f"sigproc_v2",
            **ims_import_task,
            **sigproc_v2_task,
            **lnfit_tasks,
            **nn_n2_task,
        )

        if self.force_run_name is not None:
            run.run_name = self.force_run_name

        self.report_section_run_object(run)
        template = "sigproc_v2_analyze_template.ipynb"
        self.report_section_from_template(template)

        if lnfit_tasks:
            self.report_section_from_template("lnfit_template.ipynb")

        runs += [run]

        n_runs = len(runs)
        self.report_preamble(
            utils.smart_wrap(
                f"""
                # Sigproc V2 Analyze
                ## {n_runs} run(s) processed.
                This file generated by {current_file_and_line_str()}.
                """,
                width=None,
            )
        )

        if self.classify_dyetracks:
            rb = ReportBuilder()
            rb.report_section_run_object(run)
            template = "sigproc_v2_classify_dyetracks_template.ipynb"
            rb.report_section_from_template(template)
            self.add_report("sigproc_v2_classify_dyetracks", rb)

        if self.is_timelapse and self.dyetrack_n_counts == 1:
            rb = ReportBuilder()
            rb.report_section_run_object(run)
            template = "sigproc_v2_timelapse_template.ipynb"
            rb.report_section_from_template(template)
            self.add_report("sigproc_v2_timelapse", rb)

        return runs
