from munch import Munch
from plaster.gen.base_generator import BaseGenerator
from plaster.gen import task_templates
from plaster.tools.schema.schema import Schema as s
from plaster.tools.utils import utils
from plaster.tools.calibration.calibration import Calibration
from plumbum import local


class SigprocV2Generator(BaseGenerator):
    """
    Examine sigprocv2(s) and study their results.
    Note that this requires a calibration file produced by running the run
    generated by the sigproc_v2_calibration generator.
    """

    schema = s(
        s.is_kws_r(
            **BaseGenerator.job_setup_schema.schema(),
            **BaseGenerator.lnfit_schema.schema(),
            **BaseGenerator.sigproc_source_schema.schema(),
            **BaseGenerator.sigproc_v2_schema.schema(),
        )
    )

    defaults = Munch(
        lnfit_name=None,
        lnfit_params=None,
        lnfit_dye_on_threshold=None,
        movie=False,
        n_frames_limit=None,
    )

    def generate(self):
        run_descs = []

        assert len(self.sigproc_source) == 1

        ims_import_task = task_templates.ims_import(self.sigproc_source, is_movie=False)
        sigproc_task = task_templates.sigproc_v2_analyze(self.calibration_file)

        run_name = f"sigproc_v2_analyze"
        if self.force_run_name is not None:
            run_name = self.force_run_name

        run_desc = Munch(run_name=run_name, **ims_import_task, **sigproc_task,)

        self.report_section_markdown(f"# RUN {run_desc.run_name}\n")
        self.report_section_run_object(run_desc)

        sigproc_template = "sigproc_v2_analyze_template.ipynb"
        self.report_section_from_template(sigproc_template)

        run_descs += [run_desc]

        n_run_descs = len(run_descs)
        self.report_preamble(
            utils.smart_wrap(
                f"""
                # Signal Processing Overview
                ## {n_run_descs} run(s) processed.
            """
            )
        )

        return run_descs
